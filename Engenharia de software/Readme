### Engenharia de software é uma das áreas da computação cujo foco está relacionado com análise, desenvolvimento e manutenção de softwares, bem como gestão de projetos e times.

- git clone --recursive https://github.com/CViniciusSDias/alura-ms.git

É uma área bastante extensa, pois contempla as diversas disciplinas necessárias durante todo o processo de criação e manutenação de softwares, tais como:

- Gestão de requisitos;
- Arquitetura e design de sistemas;
- Padrões de projeto;
- Banco de dados;
- Testes de software;
- Gestão de projetos;
- Infraestrutura
- deploy.

1. Design e Arquitetura
    Escrever o código de um software que deve atender as necessidades de negócios de uma organização é uma tarefa complexa. São milhares de linhas de código que precisam ser simples e entender e manter, permitindo que o software seja facilmente adaptado às mudanças que surgem com o tempo.

    Justamente por isso é essencial que o time de desenvolvimento projete uma arquitetura de software que seja simples de manter e evoluir, assim como o design do código escrito que precisa seguir padrões que garantam tais carascterísticas.

- Arquitetura de software = visao de mais alto nivel, separacao de pastas de camadas da aplicacaoclean arquitet arquitetura exagonal oner arquitet
- Design de código visao de mais baixo nivel como escrever cada classe quais padroes aplicar = design parttenes, domain driven design solid dry kiss principio POO
- O que é arquitetura hexagonal ou Ports and Adapters?  domain Drives Disgner = regra do negocio/ dominio
- Clean Architecture (Arquitetura Limpa) - O que é?  MVC MSC = Clen Architecture
- Domain-Driven Design (DDD) - O que é? design orientado ou dominio = DDD
- O que é Mensageria? Message Brokers
- Modelagem de eventos = descreve um sistema, descrever sistemas atraves do evento.
- O que é uma arquitetura orientada a eventos?

2. API e REST
    A computação no geral é muito dinâmica e evolue em um ritmo bastante acelerado. Na engenharia de software não poderia ser diferente.
    Hoje em dia é bem comum a utilização de APIs que seguem o modelo REST no desenvolvimento de aplicações multiplataforma, sendo muito importante entender sobre tais assuntos.

- O que é uma API?
- O que é REST?
- Boas práticas na Modelagem de API's REST

3. Microsserviços

   É comum alguns softwares possuirem centenas de funcionalidades, o que os tornam bastante complexos de realizar manutenções de melhorias e ajustes. Pensando em simplificar tais tipos de software, um novo modelo de arquitetura chamado de Microsserviços surgiu e se tornou um padrão no desenvolvimento de software que são maiores e mais complexos.

- O que são Microsserviços?
- Tipos de Microservices
- O que é um API Gateway?
- O que é Service Mesh?

microsservicos padroes de projeto
alguns problemas
demora no deploy
deploy possivelmente mais perigosos
falhas podem derrubar o sistema todo
1 projeto 1 tecnologia 1 deploys em todo sistema

Data service = receber dados
Bussiness service = agrega dados mais complexos
Trabslation services
Edge service = servico de ponta == BFF

- Separando Servicos
servico de dominio DDD

- Strangler pattern
quebrar um monolito, tirando as funcionalidades dele
Podemos comecar isolando os dados
podemos comecar isolando o dominio.

- Sidecar pattern
  Determine o processo comun
  construa um modulo compartilhavel
  aplique esse sidecar nos servicos que precisam dele

- API Gateway.
- ter um ponto unico de acesso ao sistema
  Dessa forma podemos ter controles de acesso unificados, autenticação em ponto único, etc. Mas essa também é a principal desvantagem: o ponto único de falha

  ponto único de entrada na aplicação com API Gateway
  Edge Service
  ideia de ter um Gateway por cliente com o Edge Pattern

CQRS
Agora em um determinado microsserviço podemos ter a aplicação de um padrão conhecido como CQRS, que significa command query responsibility segragation, que é segregação da responsabilidade entre um comando e uma busca.

Microsserviços: explorando os conceitos

NÃO pode ser chamada de API?
Uma URL.
Uma URL não é uma API. Ela é uma interface do mundo externo com um servidor, mas não necessariamente uma interface de programação, ou seja, ela pode não expor funcionalidade alguma.

necessidade de comunicação entre serviços;
Conhecemos técnicas de comunicação síncrona e assíncrona;
Entendemos falhas de comunicação e algumas soluções para elas;
Aprendemos sobre o conceito de Service Discovery e DNS.
Citamos técnicas de segurança em rede, como listas de IP, redes virtuais e firewall;
Vimos a necessidade de termos várias camadas de segurança, que é o conceito de Defense in Depth.
Analisamos a infraestrutura de um projeto com microsserviços;
Vimos como tornar serviços independentes;
Aprendemos que seguir os 12 fatores pode nos ajudar.

prendemos que cada projeto pode ter seu processo de build;
Conhecemos ferramentas como Jenkins, Travis CI e GitHub Actions;
Criamos um workflow no GitHub Actions;
Vimos o build falhar e o corrigimos;
Tornamos nosso processo mais robusto, exigindo pull requests e reviews.

Falamos sobre a possibilidade de ter mais de uma aplicação front-end;
Discutimos sobre Optimistic and Pessimistic UI Rendering;
Conhecemos o conceito de micro frontends.

### Integracao Continua

Integração Contínua (CI) significa integrar as alterações no mainline (master ou trunk) diariamente
Para usar Integração Contínua, é necessário usar um sistema de controle de versão (VCS), e no final integramos o código no repositório (usar Git não é obrigatório)
Aplicando Integração Contínua corretamente, diminuímos os problemas de integração (como merge hell), melhoramos a comunicação entre desenvolvedores e antecipamos a descoberta de bugs
Os estilos de organização de projeto
Mono-repo possui todos os projetos em um único repositório
Multi-repo separa um repositório para cada projeto

E alguns frameworks famosos da área de teste:

Selenium (automação do navegador)
Cucumber (testes de aceitação)
Postman e SoapUI (testes de API)
JMeter (stress tests)
JUnit, xUnit, PHPUnit (automação de testes)
entre muitos outros frameworks e bibliotecas

Para usar integração contínua com sucesso, é preciso ter testes automatizados
Esses testes devem verificar a maior parte do código
TDD é uma metodologia que pode ajudar na criação dos testes
Os testes representam feedback sobre a saúde/qualidade do seu projeto
O desenvolvedor deve rodar os testes antes de enviar as alterações para o repositório
Se for impossível executar todos os testes (por causa da infraestrutura ou demora da execução), é possível executar apenas os testes de unidade ou uma suíte de testes mais importantes (smoke testes)
O build do projeto deve ser simples e totalmente automatizado
É boa prática o uso de uma ferramenta especializada para o build do software
Tente usar um "single command build" para executar o build
A execução dos testes e build não deve se tornar uma razão para atrasar o build, para evitar:
Otimize build
Tente respeitar o tempo de 10 minutos para o build (alguns falam de 5 minutos)
Se o build for falhar, a ideia é que ele falhe o mais rápido possível.

O servidor de integração contínua monitora o repositório de código
Ao detectar uma alteração, deve iniciar o build do projeto
O build deve acontecer a cada novo commit
O resultado do build deve ser publicado
Os desenvolvedores devem ser notificados sobre o status do build
Um build quebrado deve ser arrumado em no máximo 10 minutos, com prioridade máxima
É responsabilidade de todos da equipe arrumar um build quebrado

A integração contínua é uma prática que faz parte da entrega contínua (continuous delivery - CD)
A entrega contínua define uma série de práticas e padrões para construir e deployar a aplicação continuamente
Não deve existir nenhum motivo técnico para impedir o deploy (apenas um motivo de negócio)
Qualquer alteração no trunk principal é releasable (pode entrar em produção)
A entrega contínua é uma evolução da integração contínua e envolve todo o ciclo do projeto, incluindo equipes de QA, deploy e operações
a diferença entre a entrega contínua e o deploy contínuo é, que no deploy contínuo todas as alterações realmente entra em produção, o tempo todo
DevOps é um movimento cultural, que visa a colaboração entre as equipes envolvidas no desenvolvimento e entrega de software, para melhorar a qualidade e velocidade do software
DevOps é sobre colaboração, melhoria e aprendizagem contínua

A entrega contínua:

Visa diminuir todo o risco do deploy através de deploys frequentes e bem testados
Normalmente é implementada através de um pipeline de entrega do software
O pipeline representa o fluxo contínuo das alterações (valor) do código até o ambiente de produção
Visa automatizar todo o processo do deploy e aplicar cada alteração
O Deploy Contínuo coloca qualquer alteração em produção
A Entrega Contínua não coloca qualquer alteração em produção, mas só por motivos de negócio

Vimos que a base da Entrega Contínua é a Integração Contínua
Vimos os princípios, que são:
Automatize
Versione
Repita
Garanta a qualidade
Defina o "done"
Crie o delivery team
Use melhoria contínua
Além disso, falamos os elementos mais importantes para implementar a entrega contínua, como a cultura DevOps, Pattern de deployment e mudanças arquiteturais.

Build/Commit stage
Automated Acceptance Testing Stage (Testes de aceitação)
User Acceptance Testing Stage (Homologação)
As etapas build e AAT são totalmente automatizadas. UAT é manual.

As etapas existem pois queremos receber feedback o mais rápido possível, ou seja, executamos os testes rápidos bem no início do pipeline.

Também falamos sobre algumas boas práticas na construção e execução do pipeline:

O pipeline é a única forma de deploy
O desempenho do pipeline importa, ou seja, otimize-o
Build do artefato no início e apenas uma vez
O build deve ser independente do ambiente
Ambientes deve ser iguais ou muito semelhantes ao de produção
Use ambientes efêmeros (temporários) onde puder
O deploy deve ser executado igual para qualquer ambiente

Ambas as etapas executam os testes de maneira automatizada
O stage de commit foca nos testes de unidade e integração.
O stage AAT foca nos testes funcionais, que testam o sistema todo, baseado em um requisito
O commit stage deve executar rápido (menos de 10 minutos) e iniciar a cada commit
O stage AAT inicia quando commit stage foi executado com sucesso
O stage AAT é mais demorado
Os testes de aceitação são mais caros de escrever e manter, mas trazem muito valor, pois testam o sistema todo. Os testes de aceitação são escritos pela equipe inteira (analista, desenvolvedor, etc).

Quando um build quebra, todos são responsáveis. Consertar o problema é prioridade da equipe.

Homologação (User Acceptance Testing Stage)
Teste de carga (Capacity Testing Stage)
O ambiente de homologação serve para o usuário final validar se o software atende aos requisitos e expectativas. A equipe deve participar nesses testes e eles representam uma oportunidade de aprender e receber feedback sobre a aceitação e usabilidade do software. Esses testes devem ser executados desde início do projeto.

O ambiente para testes de carga serve para garantir que o software atende os requisitos não funcionais, como desempenho e carga. Os testes devem fazer parte do desenvolvimento do software e ser aplicados em ciclos. Aqui, é importante definir métricas claras e monitorar o sistema.

Ter features invísiveis para o cliente também é chamado de dark launching, quando já implantamos o novo software, mas o cliente ainda não tem acesso (ou só alguns clientes).

Resumindo:

Vimos a diferença entre deploy (implantação) e release (publicação)
Deploy é colocar as alterações em produção (provisionar, configurar, instalar)
Release é deixar as alterações visíveis
Os padrões para o release do software são:

Blue-Green Deployment
Canary Release
Feature Toggles

### Scrum: agilidade em seu projeto Scrum: agilidade em seu projeto